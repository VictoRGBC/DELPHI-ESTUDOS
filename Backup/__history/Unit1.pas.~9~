unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, System.Zip,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, ShellAPI;

type
  TForm1 = class(TForm)
    edtCaminho: TEdit;
    btnBuscar: TButton;
    OpenDialog1: TOpenDialog;
    SaveDialog1: TSaveDialog;
    btnIniciar: TButton;
    Memo1: TMemo;
    lblStatus: TLabel;
    edtDestino: TEdit;
    btnSalvarEm: TButton;
    Label1: TLabel;
    Label2: TLabel;
    Label3: TLabel;
    procedure btnBuscarClick(Sender: TObject);
    procedure btnSalvarEmClick(Sender: TObject);
    procedure btnIniciarClick(Sender: TObject);
  private
    procedure VerificarIntegridadeBanco(const DBPath: string);
    procedure ZipDatabase(const DBPath, DestZip: string);
    procedure GerarBackupGBAK(const DBPath, DestGbk: string);
  public
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.btnBuscarClick(Sender: TObject);
begin
  OpenDialog1.Filter := 'Firebird Database (*.fdb)|*.fdb';
  if OpenDialog1.Execute then
    edtCaminho.Text := OpenDialog1.FileName;
end;

procedure TForm1.btnSalvarEmClick(Sender: TObject);
begin
  SaveDialog1.Title := 'Escolha o local para salvar o backup';
  SaveDialog1.FileName := 'backup.gbk';
  SaveDialog1.Filter := 'Firebird Backup (*.gbk)|*.gbk';
  SaveDialog1.Options := [ofOverwritePrompt, ofCreatePrompt];

  if SaveDialog1.Execute then
    edtDestino.Text := SaveDialog1.FileName;
end;

procedure TForm1.btnIniciarClick(Sender: TObject);
var
  DBPath, DestPath, ZipFile, GbkFile: string;
begin
  Memo1.Lines.Clear;

  DBPath := edtCaminho.Text;
  DestPath := edtDestino.Text;

  if not FileExists(DBPath) then
  begin
    ShowMessage('Banco de dados não encontrado!');
    Exit;
  end;

  if DestPath = '' then
  begin
    ShowMessage('Informe o caminho de destino do backup.');
    Exit;
  end;

  // Verifica integridade do banco
  VerificarIntegridadeBanco(DBPath);

  // Define caminhos dos arquivos gerados
  ZipFile := ChangeFileExt(DestPath, '.zip');
  GbkFile := ChangeFileExt(DestPath, '.gbk');

  Memo1.Lines.Add('Compactando banco de dados...');
  lblStatus.Caption := 'Compactando banco...';
  ZipDatabase(DBPath, ZipFile);
  Memo1.Lines.Add('Arquivo ZIP criado em: ' + ZipFile);

  Memo1.Lines.Add('Gerando backup .gbk...');
  lblStatus.Caption := 'Gerando backup .gbk...';
  GerarBackupGBAK(DBPath, GbkFile);
  Memo1.Lines.Add('Backup .gbk gerado em: ' + GbkFile);

  lblStatus.Caption := '✔️ Backup finalizado com sucesso!';
end;

procedure TForm1.ZipDatabase(const DBPath, DestZip: string);
var
  ZipFile: TZipFile;
begin
  ZipFile := TZipFile.Create;
  try
    ZipFile.Open(DestZip, zmWrite);
    ZipFile.Add(DBPath, ExtractFileName(DBPath));
    ZipFile.Close;
  finally
    ZipFile.Free;
  end;
end;

procedure TForm1.GerarBackupGBAK(const DBPath, DestGbk: string);
var
  GbakPath, DBUser, DBPass, CommandLine: string;
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  ExitCode: DWORD;
begin
  // Caminho para o gbak.exe (ajuste conforme sua instalação do Firebird)
  GbakPath := 'C:\Program Files\Firebird\Firebird_3_0\bin\gbak.exe';
  DBUser := 'SYSDBA';
  DBPass := 'masterkey';

  if not FileExists(GbakPath) then
  begin
    Memo1.Lines.Add('Erro: gbak.exe não encontrado!');
    Exit;
  end;

  CommandLine := Format('"%s" -b -user %s -pass %s "%s" "%s"',
    [GbakPath, DBUser, DBPass, DBPath, DestGbk]);

  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);
  ZeroMemory(@ProcessInfo, SizeOf(ProcessInfo));

  if CreateProcess(nil, PChar(CommandLine), nil, nil, False,
    CREATE_NO_WINDOW, nil, nil, StartupInfo, ProcessInfo) then
  begin
    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
    GetExitCodeProcess(ProcessInfo.hProcess, ExitCode);

    CloseHandle(ProcessInfo.hProcess);
    CloseHandle(ProcessInfo.hThread);

    if ExitCode = 0 then
      Memo1.Lines.Add('Backup .gbk concluído com sucesso.')
    else
      Memo1.Lines.Add('Falha ao gerar backup .gbk. Código de saída: ' + IntToStr(ExitCode));
  end
  else
  begin
    Memo1.Lines.Add('Falha ao executar gbak.');
  end;
end;

procedure TForm1.VerificarIntegridadeBanco(const DBPath: string);
var
  GfixPath, DBUser, DBPass, CommandLine: string;
  ExitCode: DWORD;
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
begin
  // Caminho para o gfix.exe (ajuste conforme sua instalação do Firebird)
  GfixPath := 'C:\Program Files (x86)\Firebird\Firebird_2_5\bin\gfix.exe';
  DBUser := 'SYSDBA';
  DBPass := 'masterkey';

  if not FileExists(GfixPath) then
  begin
    Memo1.Lines.Add('Erro: gfix.exe não encontrado!');
    Exit;
  end;

  Memo1.Lines.Add('Verificando integridade do banco...');
  lblStatus.Caption := 'Verificando integridade...';

  CommandLine := Format('"%s" -v -user %s -pass %s "%s"',
    [GfixPath, DBUser, DBPass, DBPath]);

  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);
  ZeroMemory(@ProcessInfo, SizeOf(ProcessInfo));

  if CreateProcess(nil, PChar(CommandLine), nil, nil, False,
    CREATE_NO_WINDOW, nil, nil, StartupInfo, ProcessInfo) then
  begin
    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
    GetExitCodeProcess(ProcessInfo.hProcess, ExitCode);

    CloseHandle(ProcessInfo.hProcess);
    CloseHandle(ProcessInfo.hThread);

    if ExitCode = 0 then
      Memo1.Lines.Add('Banco de dados está íntegro.')
    else
      Memo1.Lines.Add('Possível corrupção detectada no banco de dados.');
  end
  else
  begin
    Memo1.Lines.Add('Falha ao executar gfix.');
  end;
end;

end.

