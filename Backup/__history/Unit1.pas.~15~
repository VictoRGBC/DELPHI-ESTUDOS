unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, System.Zip,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, ShellAPI;

type
  TForm1 = class(TForm)
    edtCaminho: TEdit;
    btnBuscar: TButton;
    OpenDialog1: TOpenDialog;
    btnIniciar: TButton;
    Memo1: TMemo;
    lblStatus: TLabel;
    edtDestino: TEdit;
    btnSalvarEm: TButton;
    Label1: TLabel;
    Label2: TLabel;
    Label3: TLabel;
    SaveDialog1: TSaveDialog;
    procedure btnBuscarClick(Sender: TObject);
    procedure btnSalvarEmClick(Sender: TObject);
    procedure btnIniciarClick(Sender: TObject);
  private
    procedure VerificarIntegridadeBanco(const DBPath: string);
    procedure ZipDatabase(const DBPath, DestZip: string);
    procedure GerarBackupGBAK(const DBPath, DestGbk: string);
    procedure VerificarBackupRestaurando(const GbkFile: string);
  public
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.btnBuscarClick(Sender: TObject);
begin
  OpenDialog1.Filter := 'Firebird Database (*.fdb)|*.fdb';
  if OpenDialog1.Execute then
    edtCaminho.Text := OpenDialog1.FileName;
end;

procedure TForm1.btnSalvarEmClick(Sender: TObject);
begin
  SaveDialog1.Title := 'Escolha onde salvar o backup do banco';
  SaveDialog1.FileName := 'backup.gbk';
  SaveDialog1.Filter := 'Firebird Backup (*.gbk)|*.gbk';
  SaveDialog1.DefaultExt := 'gbk';

  if SaveDialog1.Execute then
    edtDestino.Text := SaveDialog1.FileName;
end;

procedure TForm1.btnIniciarClick(Sender: TObject);
var
  DBPath, DestPath, ZipFile, GbkFile: string;
begin
  Memo1.Lines.Clear;

  DBPath := edtCaminho.Text;
  DestPath := edtDestino.Text;

  if not FileExists(DBPath) then
  begin
    ShowMessage('Banco de dados não encontrado!');
    Exit;
  end;

  if DestPath = '' then
  begin
    ShowMessage('Informe o caminho de destino do backup.');
    Exit;
  end;

  // Verifica integridade
  VerificarIntegridadeBanco(DBPath);

  // Cria caminho do .zip com base no destino informado
  ZipFile := ChangeFileExt(DestPath, '.zip');
  GbkFile := ChangeFileExt(DestPath, '.gbk');

  Memo1.Lines.Add('Compactando banco de dados...');
  lblStatus.Caption := 'Compactando banco...';
  ZipDatabase(DBPath, ZipFile);
  Memo1.Lines.Add('Arquivo ZIP criado em: ' + ZipFile);

  Memo1.Lines.Add('Gerando backup .gbk...');
  lblStatus.Caption := 'Gerando backup .gbk...';
  GerarBackupGBAK(DBPath, GbkFile);
  Memo1.Lines.Add('Backup .gbk gerado em: ' + GbkFile);

  VerificarBackupRestaurando(GbkFile);
  lblStatus.Caption := 'Backup finalizado e verificado com sucesso!';

end;

procedure TForm1.ZipDatabase(const DBPath, DestZip: string);
var
  ZipFile: TZipFile;
begin
  ZipFile := TZipFile.Create;
  try
    ZipFile.Open(DestZip, zmWrite);
    ZipFile.Add(DBPath, ExtractFileName(DBPath));
    ZipFile.Close;
  finally
    ZipFile.Free;
  end;
end;

procedure TForm1.GerarBackupGBAK(const DBPath, DestGbk: string);
var
  GbakPath, DBUser, DBPass, CommandLine: string;
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  ExitCode: DWORD;
begin
  // Caminho para o gbak.exe do Firebird 2.5
  GbakPath := 'C:\Program Files (x86)\Firebird\Firebird_2_5\bin\gbak.exe';
  DBUser := 'SYSDBA';
  DBPass := 'masterkey';

  // Verifica se o gbak existe
  if not FileExists(GbakPath) then
  begin
    Memo1.Lines.Add('Erro: gbak.exe (Firebird 2.5) não encontrado!');
    Exit;
  end;

  // Monta a linha de comando para o backup
  CommandLine := Format('"%s" -b -user %s -password %s "%s" "%s"',
    [GbakPath, DBUser, DBPass, DBPath, DestGbk]);

  Memo1.Lines.Add('Executando: ' + CommandLine);

  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);
  ZeroMemory(@ProcessInfo, SizeOf(ProcessInfo));

  // Cria o processo (modo oculto)
  if CreateProcess(nil, PChar(CommandLine), nil, nil, False,
    CREATE_NO_WINDOW, nil, nil, StartupInfo, ProcessInfo) then
  begin
    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
    GetExitCodeProcess(ProcessInfo.hProcess, ExitCode);

    CloseHandle(ProcessInfo.hProcess);
    CloseHandle(ProcessInfo.hThread);

    if ExitCode = 0 then
    begin
      Memo1.Lines.Add('✅ Backup .gbk gerado com sucesso.');
    end
    else
    begin
      Memo1.Lines.Add('❌ Erro ao gerar backup. Código de saída: ' + IntToStr(ExitCode));
    end;
  end
  else
  begin
    Memo1.Lines.Add('❌ Falha ao iniciar o processo de backup.');
  end;
end;


procedure TForm1.VerificarIntegridadeBanco(const DBPath: string);
var
  GfixPath, DBUser, DBPass, CommandLine: string;
  ExitCode: DWORD;
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
begin
  GfixPath := 'C:\Program Files (x86)\Firebird\Firebird_2_5\bin\gfix.exe';
  DBUser := 'SYSDBA';
  DBPass := 'masterkey';

  if not FileExists(GfixPath) then
  begin
    Memo1.Lines.Add('Erro: gfix.exe não encontrado!');
    Exit;
  end;

  Memo1.Lines.Add('Verificando integridade do banco...');
  lblStatus.Caption := 'Verificando integridade...';

  CommandLine := Format('"%s" -v -user %s -pass %s "%s"',
    [GfixPath, DBUser, DBPass, DBPath]);

  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);
  ZeroMemory(@ProcessInfo, SizeOf(ProcessInfo));

  if CreateProcess(nil, PChar(CommandLine), nil, nil, False,
    CREATE_NO_WINDOW, nil, nil, StartupInfo, ProcessInfo) then
  begin
    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
    GetExitCodeProcess(ProcessInfo.hProcess, ExitCode);

    CloseHandle(ProcessInfo.hProcess);
    CloseHandle(ProcessInfo.hThread);

    if ExitCode = 0 then
      Memo1.Lines.Add('Banco de dados está íntegro.')
    else
      Memo1.Lines.Add('Possível corrupção detectada no banco de dados.');
  end
  else
  begin
    Memo1.Lines.Add('Falha ao executar gfix.');
  end;
end;

procedure TForm1.VerificarBackupRestaurando(const GbkFile: string);
var
  GbakPath, DBUser, DBPass, TempFdb, CommandLine: string;
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  ExitCode: DWORD;
begin
  GbakPath := 'C:\Program Files (x86)\Firebird\Firebird_2_5\bin\gbak.exe';
  DBUser := 'SYSDBA';
  DBPass := 'masterkey';
  TempFdb := ChangeFileExt(GbkFile, '_restored.fdb');

  if not FileExists(GbakPath) then
  begin
    Memo1.Lines.Add('Erro: gbak.exe (Firebird 2.5) não encontrado para verificação do backup!');
    Exit;
  end;

  if not FileExists(GbkFile) then
  begin
    Memo1.Lines.Add('Erro: arquivo .gbk não encontrado para verificação!');
    Exit;
  end;

  Memo1.Lines.Add('Verificando integridade do backup através da restauração...');
  lblStatus.Caption := 'Verificando backup restaurando...';

  CommandLine := Format('"%s" -c -user %s -password %s "%s" "%s"',
    [GbakPath, DBUser, DBPass, GbkFile, TempFdb]);

  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);
  ZeroMemory(@ProcessInfo, SizeOf(ProcessInfo));

  if CreateProcess(nil, PChar(CommandLine), nil, nil, False,
    CREATE_NO_WINDOW, nil, nil, StartupInfo, ProcessInfo) then
  begin
    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
    GetExitCodeProcess(ProcessInfo.hProcess, ExitCode);

    CloseHandle(ProcessInfo.hProcess);
    CloseHandle(ProcessInfo.hThread);

    if ExitCode = 0 then
    begin
      Memo1.Lines.Add('✅ Backup restaurado com sucesso. Arquivo .gbk é válido.');
    end
    else
    begin
      Memo1.Lines.Add('❌ Erro ao restaurar o backup. Código de saída: ' + IntToStr(ExitCode));
    end;
  end
  else
  begin
    Memo1.Lines.Add('❌ Falha ao tentar restaurar o backup para verificação.');
  end;

  // Tenta remover o banco restaurado temporário
  if FileExists(TempFdb) then
  begin
    try
      DeleteFile(TempFdb);
      Memo1.Lines.Add('🗑 Banco temporário restaurado foi excluído com sucesso.');
    except
      on E: Exception do
        Memo1.Lines.Add('⚠ Falha ao excluir banco restaurado: ' + E.Message);
    end;
  end;
end;


end.

